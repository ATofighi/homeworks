\documentclass[12pt]{article}
\usepackage{HomeWorkTemplate}
\usepackage{circuitikz}
\usepackage{tikz}
\usepackage{float}
\usepackage{mathtools}
\usepackage{xepersian}
\usetikzlibrary{arrows,automata}
\usetikzlibrary{circuits.logic.US}
\settextfont{XB Niloofar}
\newcounter{problemcounter}
\newcounter{subproblemcounter}
\linespread{1.2}
\setcounter{problemcounter}{1}
\setcounter{subproblemcounter}{1}
\newcommand{\grade}[1]{\textbf{(#1 نمره)}}
\newcommand{\prf}{\lr{PRF}}
\newcommand{\vrfyk}{\text{Vrfy}_k}
\newcommand{\mack}{\text{Mac}_k}
\newcommand{\enck}{\text{Enc}_pk}
\newcommand{\deck}{\text{Dec}_sk}
\newcommand{\CR}{\lr{ collision resistant }}
\newcommand{\problem}[1]
{
\section*{
مسأله‌ی
\arabic{problemcounter} 
\stepcounter{problemcounter}
\setcounter{subproblemcounter}{1}
#1
}
}
\newcommand{\subproblem}{
\subsection*{\alph{subproblemcounter})}\stepcounter{subproblemcounter}
}
\newcommand{\n}{

\null

}
\begin{document}

\handout
{مقدمه‌ای بر رمزنگاری}
{}
{دانشجو: علیرضا توفیقی محمدی}
{سری ۴}
{شماره‌ی دانشجویی: 96100363}

\problem{} % 1
\subproblem{} % 1.1
\CR
است، چراکه اگر $m_1, m_2$ یافت شود که $H_1(m_1) = H_1(m_2)$ نتیجه می‌گیریم:
$$
H(m_1 || 0) = H(m_2 || 0)
$$
پس $H$ نیز \CR نیست.
\subproblem{} % 1.2
\CR
است، چراکه اگر $m_1, m_2$ یافت شود که $H_1(m_1) = H_1(m_2)$ نتیجه می‌گیریم:
$$
H(m_1 || m_1) = H(m_2 || m_2)
$$
پس $H$ نیز \CR نیست.

\subproblem{} % 1.3
\CR
نیست، برای اثبات فرض کنید $H$ یک تابع هش \CR باشد، حال تابع $H'$ با تعریف زیر را در نظر بگیرید:
$$
H'(m) = 0^{32} || H(m)
$$
این تابع نیز \CR است، چرا که اگر $m_1, m_2$ ای یافت شود که $H'(m_1) = H'(m_2)$ نتیجه می‌گیریم $H(m_1) = H(m_2)$. اما اگر $H_3$ را با تابع $H'$ تعریف کنیم، همیشه $0^{32}$ را می‌دهد پس \CR نیست.

\subproblem{} % 1.4
\CR
است، چراکه اگر $m_1, m_2$ یافت شود که $H_1(m_1) = H_1(m_2)$ نتیجه می‌گیریم:
$$
H(m_1) || H(0) = H(m_2) || H(0)
$$
پس $H(m_1) = H(m_2)$ و در نتیجه $H$ نیز \CR نیست.

\subproblem{} % 1.5
\CR
نیست چراکه $H_5(0^n) = H_5(1^n)$.
\subproblem{} % 1.6
\CR
نیست چراکه $H_6(0^n) = H_6(1^n)$.

\problem{} % 2
اگر $m$ سمپل برداریم، 
$\binom{m}{3} = O(m^3)$
تا سه‌تایی داریم که هر کدام به احتمال $2^{-2n}$ یک \lr{3-collision} اند، پس برای اینکه یک \lr{3-collision} پیدا کنیم لازم است $m$ ما آنقدر زیاد باشد که امیدریاضی \lr{3-collision}ها حداقل یک شود، پس خواهیم داشت:
$$ c m^3 \times 2^{-2n} \geq 1 \implies m = O(2^\frac{2n}{3})$$
پس به $ O(2^\frac{2n}{3})$ تا سمپل نیاز داریم.
\problem{} % 3
حمله کننده $A$ را در نظر بگیرید که ابتدا $0^{2n}$ را پرسیده و 
$\langle a, b \rangle$
را دریافت می‌کند، سپس $1^{2n}$ را می‌پرسد و 
$\langle c, d \rangle$
را دریافت می‌کند، طبق الگوریتم مکمان می‌دانیم که 
$F_k(0^n) = a, F_k(F_k(1^n)) = d$
پس 
$\mack(0^n1^n) = \langle a, d \rangle$
و در نتیجه حمله کننده $0^n1^n$ و 
$\langle a, d \rangle$
را خروجی می‌دهد و با مزیت یک مک را جعل می‌کند.

\problem{} %4 
چون کلید \lr{AES} ۱۲۸ بیت است، پس نیمه‌ی اول \lr{IV} است و نیمه‌ی دوم برابر با 
$\Enc_k(\text{IV} \oplus m) = c$
است، چون می‌خواهیم متن رمزی را جوری تغییر دهیم که $m'$ شود، کافی است \lr{IV} را تغییر دهیم که $m'$ را بسازیم، برای اینکار $m \oplus m'$ را حساب کرده و با \lr{IV} ایکس‌اور می‌کنیم، در نتیجه اگر متن جدید را دیکریپت کند خواهد داشت:
$$
\Dec_k(c) \oplus \text{IV}' = \Dec_k(c) \oplus (\text{IV} \oplus (m \oplus m')) = \text{IV} \oplus m \oplus (\text{IV} \oplus (m \oplus m'))
$$
همچنین ایکس‌اور پد شده‌ی دو پیام برابر با
\lr{00000000000000000400000000000000}
است و در نتیجه پیام جعل شده برابر با
\lr{20814804c1767293bd9f1d9cab3bc3e7 ac1e37bfb15599e5f40eef805488281d}
است.

\problem{} % 5
اگر 
$t(n) = O(\log n)$
باشد، تعداد کل مک‌های مختلفی که قابل تولید اند برابر با
$2^{t(n)} = O(n)$
خواهد بود، در نتیجه، اگر یک رشته‌ی تصادفی را انتخاب کرده و یک مک تصادفی برای آن خروجی دهیم، به احتمال حداقل
$\frac{1}{2^{t(n)}} = \frac{1}{O(n)} = \Omega(n^{-1})$
درست جواب می‌دهیم که احتمال موفقیت غیرناچیز است، پس حمله کننده‌ای که بدون استفاده از اوراکل، تصادفی جواب دهد به احتمال غیرناچیز جعل می‌کند و در نتیجه \lr{MAC} ما امن نیست.
\problem{} % 6
یک خانواده از توابع 
$\{h_k: \{0, 1\}^{m(k)} \rightarrow \{0, 1\}^{l(k)}\}$
که توسط الگوریتم چند جمله‌ای $G$ تولید شده‌اند را 
\lr{pre-image resistant hash functions}
گوییم اگرکه،
$\forall k: |m(k)| > |l(k)|$
و $h_k$ در زمان چند جمله‌ای بر حسب $k$ قابل محاسبه باشد و برای هر حمله‌کننده‌ی \lr{PPT} مثل $A$ تابع ناچیز $\epsilon(\cdot)$ وجود داشته باشد که:
$$
\forall n: \Pr[k \leftarrow G(1^n); y \leftarrow \{0, 1\}^{m(k)}; x \leftarrow A(k, 1^n, h(y)); h_k(x) = h(y)] < \epsilon(n)
$$
\\
یک خانواده از توابع 
$\{h_k: \{0, 1\}^{m(k)} \rightarrow \{0, 1\}^{l(k)}\}$
که توسط الگوریتم چند جمله‌ای $G$ تولید شده‌اند را 
\lr{second pre-image resistant hash functions}
گوییم اگرکه،
$\forall k: |m(k)| > |l(k)|$
و $h_k$ در زمان چند جمله‌ای بر حسب $k$ قابل محاسبه باشد و برای هر حمله‌کننده‌ی \lr{PPT} مثل $A$ تابع ناچیز $\epsilon(\cdot)$ وجود داشته باشد که:
$$
\forall n: \Pr[k \leftarrow G(1^n); x \leftarrow \{0, 1\}^{m(k)}; x' \leftarrow A(k, 1^n, x); h_k(x') = h_k(x) \land x \neq x'] < \epsilon(n)
$$
\\
حال ثابت می‌کنیم اگر خانواده‌ای از هش‌ها 
\lr{second pre-image resistant}
نباشند، \CR نیز نیستند، برای اثبات کافی است حمله‌کننده‌ی $A$ را که به احتمال غیرناچیز 
\lr{second pre-image}
پیدا می‌کند را در نظر بگیریم، حال حمله کننده‌ی $A'$ را می‌سازیم که به شکل زیر عمل می‌کند:
$$
A'(k, 1^n): x \leftarrow \{0, 1\}^{m(k)}; x' \leftarrow A(k, 1^n, x); \text{outputs} (x, x')
$$
در واقع $A'$ یکی از رشته‌ها را تصادفی ساخته و \lr{second pre-image} آن‌را از $A$ می‌گیرد و به احتمالی که $A$ پیری‌امیج پیدا می‌کند، کالیژن پیدا می‌کند.
\\
همچنین اگر خانواده‌ای از رمز‌ها
\lr{pre-image resistant}
نباشد، 
\lr{second pre-image resistant}
نیز نیست، برای اثبات فرض کنید حمله کننده‌ی $A$ برای خانواده‌ی هش‌های $h_k$ وجود دارد که با احتمال غیرناچیز \lr{pre image} پیدا می‌کند. حال حمله کننده‌ی $A'$ را می‌سازیم که \lr{second pre-image} پیدا کند. به این شکل که:
$$
A'(k, 1^n, x): y \leftarrow h_k(x); \text{outputs} A(k, 1^n, y)
$$
که با احتمال احتمال \lr{second pre-image} پیدا می‌کند.


\problem{} % 7
اولا $G_1$ \CR است، چراکه اگر پیدا کردن کالیژن برایش سخت نباشد، $m_1, m_2$ ای پیدا می‌کنیم که 
$$G_1(m_1) = G_1(m_2) \implies H_2(H_1(m_1)) = H_2(H_1(m_2)) $$
در نتیجه یا $H_1(m_1) = H_1(m_2)$ که در نتیجه $H_1$ \CR نیست یا  
$H_1(m_1) \neq H_1(m_2)$
که در نتیجه $H_2$ \CR نیست.
\\
همچنین $G_2$ نیز \CR است، چراکه اگر پیدا کردن کالیژن برایش سخت نباشد، $m_1, m_2$ ای پیدا می‌کنیم که 
$$
G_2(m_1) = G_2(m_2) \implies H_1(m_1) || H_1(m_1) = H_1(m_2) || H_1(m_2) \implies H_1(m_1) = H_1(m_2)
$$
و در نتیجه $H_1$ نیز \CR نیست.
\\
حال اگر $H_2$ \CR نباشد، برای $G_2$ تغییری ایجاد نمی‌شود چراکه به $H_2$ ربطی ندارد، اما $G_1$ لزوما \CR بودنش را از دست نمی‌دهد، چرا که نیاز به دوپیام $c_1, c_2$ داریم که $H_2(c_1) = H_2(c_2)$ و $c_1, c_2$ جوابی برای $H_1$ باشند. اما ممکن است اصلا کالیژنی که می‌توانیم پیدا کنیم برای طولی بیشتر از طول خروجی $H_1$ باشد.
\\
اما $G_3$ \CR نیست، چرا $m_1, m_2$ که $H_2(m_1) = H_2(m_2)$ شود، داریم:
$$
H_1(H_2(m_1)) = H_1(H_2(m_2)) \implies G_3(m_1) = G_3(m_2)
$$
.
\problem{} % 8
\subproblem{} % 8.1
فرض کنید $H$ \CR نباشد، پس حمله کننده‌ی \lr{PPT} مثل $A$ موجود باشد که
$$
Pr[k \leftarrow \Gen(1^n); (x_1, x_2) \leftarrow A(k, 1^n); x_1 \neq x_2 \land H^k(x_1) = H^k(x_2)]
$$
غیرناچیز باشد، چون
$H^{s_1,s_2}(x) = H^{s_1,s_2}(y) \implies H_1^{s_1}(x) = H_1^{s_1}(y) \land H_2^{s_2}(x) = H_2^{s_2}(y)$
پس اگر حمله کننده‌ی $A_1$ را بسازیم که به صورت زیر کار کند:
$$
A_1(s_1, 1^n): s_2 \leftarrow \Gen_2(1^n); x_1, x_2 \leftarrow A(\langle s_1, s_2 \rangle, 1^n) \text{outputs} x_1, x_2
$$
حال $A_1$ یک حمله کننده با مزیت غیرناچیز برای $H_1$ است، همچنین به طریق مشابه
$$
A_2(s_2, 1^n): s_1 \leftarrow \Gen_1(1^n); x_1, x_2 \leftarrow A(\langle s_1, s_2 \rangle, 1^n) \text{outputs} x_1, x_2
$$ 
نیز یک حمله کننده با مزیت غیرناچیز برای $H_2$ است. پس اگر $H$ \CR نباشد، هر دوی $H_1, H_2$ \CR نیستند، پس اگر یکی \CR باشد، $H$ نیز \CR است.
\subproblem{} % 8.2
% TODO

\problem{} % 9

\problem{} % 10

\problem{} % 11
در این مسئله برای سادگی $E_x(y)$ را الگوریتم \lr{AES} روی $y$ با کلید $x$ در نظر گرفته و $D_x(y)$ را الگوریتم $\text{AES}^{-1}$ روی $y$ با کلید $x$ در نظر می‌گیریم.
\subproblem{} % 11.1
باید $x_1, y_1, x_2, y_2$ پیدا کنیم که:
$$
E_{y_1}(x_1) \oplus y_1 = E_{y_2}(x_2) \oplus y_2 \iff x_2 = D_{y_2}(E_{y_1}(x_1) \oplus y_1 \oplus y_2)
$$
پس با انتخاب مقادیر دلخواه برای $x_1, y_1, y_2$ می‌توان $x_2$ را محاسبه کرد و یک کالیژن پیدا کرد.
\subproblem{} % 11.2
باید $x_1, y_1, x_2, y_2$ پیدا کنیم که:
$$
E_{x_1}(x_1) \oplus y_1 = E_{x_2}(x_2) \oplus y_2 \iff E_{x_1}(x_1) \oplus y_1 \oplus E_{x_2}(x_2) = y_2
$$
پس
پس با انتخاب مقادیر دلخواه برای $x_1, y_1, x_2$ می‌توان $y_2$ را محاسبه کرد و یک کالیژن پیدا کرد.

\problem{} % 12

\problem{} % 13
\subproblem{} % 13.1
در زمزنگاری داریم:
$$
L_i = R_{i-1}
$$$$
R_i = L_{i-1} \oplus F_{k_i}(R_{i-1})
$$
پس در تابع وارون خواهیم داشت:
$$
R_{i-1} = L_{i}
$$$$
L_{i-1} = R_i \oplus F_{k_i}(L_{i})
$$
پس می‌توان $L_0, R_0$ را از روی $L_2, R_2$ محاسبه کرد.
\subproblem{} % 13.2
برای ورودی 
$0^{64}$
 خروجی برابر با
$F_{k_1}(0^{32}) || F_{k_2}(F_{k_1}(0^{32}))$
خواهد بود و برای 
$0^{32}1^{32}$
خروجی برابر با
$1^{32} \oplus F_{k_1}(0^{32}) || F_{k_2}(1^{32} \oplus F_{k_1}(0^{32}))$
است، پس کافی است چک کنیم کدام گزینه ایکس‌اور نیمه‌های اولشان برابر با $1^{32}$ خواهد شد. که مورد سوم چنین است، پس مورد سوم پاسخ است.
\subproblem{} % 13.3
کافی است حمله کننده $0^{64}$ و $0^{32}1^{32}$ را به اوراکل بدهد و ۳۲ بیت اول خروجی را باهم ایکس‌اور کند، اگر $1^{32}$ شد ۱ بیرون دهد و در غیر اینصورت ۰ بیرون دهد.
\\
اگر تابع $E$ باشد به احتمال یک، یک بیرون داده و اگر تابع یک تابع تصادفی باشد به احتمال $2^{-32}$ یک بیرون می‌دهد و در نتیجه مزیت حمله کننده برابر با
$1 - 2^{-32}$
است.
\end{document}
